# Linux 02

## Part 1. Инструмент **ipcal**

---

### 1.1. Сети и маски

---

1) Адрес сети *192.167.38.54/13*

![1.png](Linux%2002/1.png)

2)Перевод маски *255.255.255.0* в префиксную и двоичную запись, */15* в обычную и двоичную, *11111111.11111111.11111111.11110000* в обычную и префиксную

![2.png](Linux%2002/2.png)

![3.png](Linux%2002/3.png)

3) Минимальный и максимальный хост в сети *12.167.38.4* при масках: */8*, *11111111.11111111.00000000.00000000*, *255.255.254.0* и */4*

### 1.2 localhost

---

можно ли обратиться к приложению, работающему на localhost, со следующими IP:

1. *194.34.23.100 - нет*
2. *127.0.0.2 - да (имеется loopback)*
3. *127.1.0.1 - да (имеется loopback)*
4. *128.0.0.1 - нет*

![6.png](Linux%2002/6.png)

![5.png](Linux%2002/5.png)

### 1.3 Диапазоны и сегменты сетей

---

![7.png](Linux%2002/7.png)

1) Какие IP можно использовать в качестве публичного, а какие только в качестве частных

1. *10.0.0.45 - частные*
2. *134.43.0.2 - публичный*
3. *192.168.4.2 - частные*
4. *172.20.250.4 - частный*
5. *172.0.2.1 - публичный*
6. *192.172.0.1 - публичный*
7. *172.68.0.2 - публичный*
8. *172.16.255.255 - частный*
9. *10.10.10.10 - частные*
10. *192.169.168.1 - публичные*

2) Какие из IP адресов шлюза возможны у сети *10.10.0.0/18*:

1. *10.0.0.1 - невозможен*
2. *10.10.0.2 - возможен*
3. *10.10.10.10 - возможен*
4. *10.10.100.1 - невозможен*
5. *10.10.1.255 - возможен*

## Part 2. Статическая маршрутизация между двумя машинами

---

Подними две виртуальные машины (далее -- ws1 и ws2).

![8.png](Linux%2002/8.png)

Опиши сетевой интерфейс, соответствующий внутренней сети, на обеих машинах и задать следующие адреса и маски: ws1 - *192.168.100.10*, маска */16*, ws2 - *172.24.116.8*, маска */12*.

![17.png](Linux%2002/17.png)

С помощью команды `ip a` посмотри существующие сетевые интерфейсы.

![9.png](Linux%2002/9.png)

![10.png](Linux%2002/10.png)

### 2.1. Добавление статического маршрута вручную

---

**Перезапускаем машины командой sudo reboot**

**Добавляем статический маршрут от одной машины до другой с помощью файла *etc/netplan/00-installer-config.yaml***

![13.png](Linux%2002/13.png)

![14.png](Linux%2002/14.png)

### 2.2. Добавление статического маршрута с сохранением

**Пропингуем соединение между машинами**

![11.png](Linux%2002/11.png)

![12.png](Linux%2002/12.png)

## Part 3. Утилита **iperf3**

---

### 3.1. Скорость соединения

Переведи и запиши в отчёт: 8 Mbps в MB/s, 100 MB/s в Kbps, 1 Gbps в Mbps.

8 Mbps = 1 MB/s 100 MB/s = 819200 Kbps 1 Gbps = 1024 Mbps

### 3.2. Утилита **iperf3**

Измерь скорость соединения между ws1 и ws2.

Устанавливаем утилиту iperf3

![18.png](Linux%2002/18.png)

ws1 выступает в роли сервера

![19.png](Linux%2002/19.png)

ws1 выступает в роли клиента

![20.png](Linux%2002/20.png)

## Part 4. Сетевой экран

---

### 4.1. Утилита **iptables**

(Ссылки на материалы по iptables [тут](https://www.opennet.ru/man.shtml?topic=iptables&category=8&russian=0) и [тут](https://losst.pro/nastrojka-iptables-dlya-chajnikov))

**Создаем файл */etc/firewall.sh*, имитирующий фаерволл, на ws1 и ws2**

![21.png](Linux%2002/21.png)

![22.png](Linux%2002/22.png)

Запусти файлы на обеих машинах командами `chmod +x /etc/firewall.sh` и `/etc/firewall.sh`.

![24.png](Linux%2002/24.png)

![23.png](Linux%2002/23.png)

### 4.2. Утилита **nmap**

устанавливаем nmap `sudo apt install nmap`

Командой **ping** найди машину, которая не «пингуется», после чего утилитой **nmap** покажи, что хост машины запущен.

ws-1

![26.png](Linux%2002/26.png)

![27.png](Linux%2002/27.png)

ws-2

![25.png](Linux%2002/25.png)

![28.png](Linux%2002/28.png)

## Part 5. Статическая маршрутизация сети

---

### 5.1. Настройка адресов машин

Настрой конфигурации машин в *etc/netplan/00-installer-config.yaml* согласно сети на рисунке.

- В отчёт помести скрины с содержанием файла *etc/netplan/00-installer-config.yaml* для каждой машины.

ws11

![35.png](Linux%2002/35.png)

ws22

![36.png](Linux%2002/36.png)

ws21

![37.png](Linux%2002/37.png)

r1

![38.png](Linux%2002/38.png)

r2

![39.png](Linux%2002/39.png)

Сохраняем результат с помощью `sudo netplan apply`

Командой `ip -4 a` проверяем, что адреса машин заданы верно

ws11

![40.png](Linux%2002/40.png)

ws22

![41.png](Linux%2002/41.png)

ws21

![42.png](Linux%2002/42.png)

r1

![43.png](Linux%2002/43.png)

r2

![44.png](Linux%2002/44.png)

Пропингуем ws22 с ws21

![45.png](Linux%2002/45.png)

Пропингуем r1 с ws11.

![46.png](Linux%2002/46.png)

### 5.2. Включение переадресации IP-адресов

Для включения переадресации IP, выполни команду на роутерах:

`sudo sysctl -w net.ipv4.ip_forward=1`

r1

![48.png](Linux%2002/48.png)

r2

![49.png](Linux%2002/49.png)

В файл  */etc/sysctl.conf* и добавили в него строку

r1

![50.png](Linux%2002/50.png)

r2

![51.png](Linux%2002/51.png)

`net.ipv4.ip_forward = 1`*При использовании этого подхода, IP-переадресация включена на постоянной основе.*

### **5.3. Установка маршрута по-умолчанию**

Пример вывода команды `ip r` после добавления шлюза:

```
default via 10.10.0.1 dev eth0
10.10.0.0/18 dev eth0 proto kernel scope link src 10.10.0.2

```

Настроили маршрут по-умолчанию (шлюз) для рабочих станций. Для этого добавили `default` перед IP роутера в файле конфигураций.

ws11

![47.png](Linux%2002/47.png)

ws22

![52.png](Linux%2002/52.png)

ws21

![53.png](Linux%2002/53.png)

r1

![59.png](Linux%2002/59.png)

r2

![60.png](Linux%2002/60.png)

Вызови `ip r` и покажи, что добавился маршрут в таблицу маршрутизации.

ws11

![54.png](Linux%2002/54.png)

ws22

![55.png](Linux%2002/55.png)

ws21

![56.png](Linux%2002/56.png)

Пропингуй с ws11 роутер r2 и покажи на r2, что пинг доходит. Для этого используй команду:

`tcpdump -tn -i eth0`

![57.png](Linux%2002/57.png)

![58.png](Linux%2002/58.png)

### 5.4. Добавление статических маршрутов

Добавили в роутеры r1 и r2 статические маршруты в файле конфигураций

```
# Добавь в конец описания сетевого интерфейса eth1:
- to: 10.20.0.0
  via: 10.100.0.12

```

r2

![61.png](Linux%2002/61.png)

r1

![62.png](Linux%2002/62.png)

Вызываем `ip r` и показываем таблицы с маршрутами на обоих роутерах. Пример таблицы на r1:

```
10.100.0.0/16 dev eth1 proto kernel scope link src 10.100.0.11
10.20.0.0/26 via 10.100.0.12 dev eth1
10.10.0.0/18 dev eth0 proto kernel scope link src 10.10.0.1

```

r1

![64.png](Linux%2002/64.png)

r2

![65.png](Linux%2002/65.png)

Запускаем команды на ws11:

![63.png](Linux%2002/63.png)

Почему для адреса 10.10.0.0/[маска сети] был выбран маршрут, отличный от 0.0.0.0/0, хотя он попадает под маршрут по-умолчанию ?

- Это можно объяснить тем, что маршрут по умолчанию имеет более низкий приоритет, маршрут 0.0.0.0/0 представляет собой маршрут по умолчанию, который используется, когда нет более конкретных маршрутов для указанного адреса. Для сети 10.10.0.0 мы создали правило, соответственно используется созданный маршрут

### 5.5. Построение списка маршрутизаторов

Запусти на r1 команду дампа:

`tcpdump -tnv -i eth0`

![68.png](Linux%2002/68.png)

При помощи утилиты **traceroute** построй список маршрутизаторов на пути от ws11 до ws21.

![67.png](Linux%2002/67.png)

Объясни принцип работы построения пути при помощи **traceroute:**

- Traceroute определяет промежуточные маршрутизаторы, отправляя серии пакетов данных к целевому узлу с постепенно увеличивающимся значением TTL («время жизни»). Поле TTL указывает максимальное количество маршрутизаторов, через которые может пройти пакет. Первый пакет отправляется с TTL, равным 1, и первый маршрутизатор возвращает сообщение ICMP о невозможности доставки данных. Traceroute фиксирует адрес маршрутизатора и время между отправкой пакета и получением ответа, выводя эти данные на монитор. Затем отправляется следующий пакет с TTL, равным 2, позволяя первому маршрутизатору пропустить его дальше.

### 5.6. Использование протокола **ICMP** при маршрутизации

Запусти на r1 перехват сетевого трафика, проходящего через eth0 с помощью команды:

`tcpdump -n -i eth0 icmp`

![70.png](Linux%2002/70.png)

Пропингуй с ws11 несуществующий IP (например, *10.30.0.111*) с помощью команды:

![69.png](Linux%2002/69.png)

## Part 6. Динамическая настройка IP с помощью **DHCP**

Для r2 настрой в файле */etc/dhcp/dhcpd.conf* конфигурацию службы **DHCP**:

1) Укажи адрес маршрутизатора по-умолчанию, DNS-сервер и адрес внутренней сети. Пример файла для r2:

```
subnet 10.100.0.0 netmask 255.255.0.0 {}

subnet 10.20.0.0 netmask 255.255.255.192
{    range 10.20.0.2 10.20.0.50;
     option routers 10.20.0.1; 
     option domain-name-servers 10.20.0.1;
}
```

Скачиваем isc-dhcp-server командой `sudo apt install isc-dhcp-server`

Редактируем файл */etc/dhcp/dhcpd.conf*

![71.png](Linux%2002/71.png)

2) В файле *resolv.conf* пропиши `nameserver 8.8.8.8`.

![72.png](Linux%2002/72.png)

Перезагрузи службу **DHCP** командой `systemctl restart isc-dhcp-server`. Машину ws21 перезагрузи при помощи `reboot` и через `ip a` покажи, что она получила адрес.

![Снимок экрана 2024-07-19 в 17.30.52.png](Linux%2002/%25D0%25A1%25D0%25BD%25D0%25B8%25D0%25BC%25D0%25BE%25D0%25BA_%25D1%258D%25D0%25BA%25D1%2580%25D0%25B0%25D0%25BD%25D0%25B0_2024-07-19_%25D0%25B2_17.30.52.png)

Также пропингуй ws22 с ws21.

![Снимок экрана 2024-07-19 в 17.35.15.png](Linux%2002/%25D0%25A1%25D0%25BD%25D0%25B8%25D0%25BC%25D0%25BE%25D0%25BA_%25D1%258D%25D0%25BA%25D1%2580%25D0%25B0%25D0%25BD%25D0%25B0_2024-07-19_%25D0%25B2_17.35.15.png)

Укажи MAC адрес у ws11, для этого в *etc/netplan/00-installer-config.yaml* надо добавить строки: `macaddress: 10:10:10:10:10:BA`, `dhcp4: true`.

![75.png](Linux%2002/75.png)

Для r1 настрой аналогично r2, но сделай выдачу адресов с жесткой привязкой к MAC-адресу (ws11). Проведи аналогичные тесты.

![76.png](Linux%2002/76.png)

![77.png](Linux%2002/77.png)

Запроси с ws21 обновление ip адреса.

до обновления

![78.png](Linux%2002/78.png)

после обновления

![79.png](Linux%2002/79.png)

Какими опциями **DHCP** сервера пользовался в данном пункте.

- Команда `sudo dhclient -r enp0s8` освобождает текущий адрес интерфейса enp0s8.
- Команда `sudo dhclient enp0s8` задает новый адрес указанному интерфейсу.

## **Part 7. NAT**

В файле */etc/apache2/ports.conf* на ws22 и r1 измени строку `Listen 80` на `Listen 0.0.0.0:80`, то есть сделай сервер Apache2 общедоступным.

Устанавливаем утилиту `sudo apt install apache2`

ws22

![80.png](Linux%2002/80.png)

r1

![81.png](Linux%2002/81.png)

Запусти веб-сервер Apache командой `service apache2 start` на ws22 и r1.

r1

![82.png](Linux%2002/82.png)

ws22

![83.png](Linux%2002/83.png)

Добавь в фаервол, созданный по аналогии с фаерволом из Части 4, на r2 следующие правила:

1. Удаление правил в таблице filter - `iptables -F`;
2. Удаление правил в таблице "NAT" - `iptables -F -t nat`;
3. Отбрасывать все маршрутизируемые пакеты - `iptables --policy FORWARD DROP`.

Запусти файл также, как в Части 4.

Создаем файл `/etc/firewall.sh`

![84.png](Linux%2002/84.png)

Даем права на исполнение `sudo chmod +x /etc/firewall.sh`

Запускаем `sudo sh /etc/firewall.sh`

Проверь соединение между ws22 и r1 командой `ping`.

![85.png](Linux%2002/85.png)

4) Разрешить маршрутизацию всех пакетов протокола **ICMP**.

![86.png](Linux%2002/86.png)

Проверь соединение между ws22 и r1 командой `ping`.

![87.png](Linux%2002/87.png)

5) Включи **SNAT**, а именно маскирование всех локальных ip из локальной сети, находящейся за r2 (по обозначениям из Части 5 - сеть 10.20.0.0).

*Совет: стоит подумать о маршрутизации внутренних пакетов, а также внешних пакетов с установленным соединением.*

6) Включи **DNAT** на 8080 порт машины r2 и добавить к веб-серверу Apache, запущенному на ws22, доступ извне сети.

*Совет: стоит учесть, что при попытке подключения возникнет новое tcp-соединение, предназначенное ws22 и 80 порту.*

Вносим необходимые команды `sudo nano /etc/firewall.sh`

![88.png](Linux%2002/88.png)

Проверь соединение по TCP для **SNAT**: для этого с ws22 подключиться к серверу Apache на r1 командой:

`telnet [адрес] [порт]`

![89.png](Linux%2002/89.png)

Проверь соединение по TCP для **DNAT**: для этого с r1 подключиться к серверу Apache на ws22 командой `telnet` (обращаться по адресу r2 и порту 8080).

![90.png](Linux%2002/90.png)

## Part 8. Дополнительно. Знакомство с **SSH Tunnels**

Запусти на r2 фаервол с правилами из Части 7.

![91.png](Linux%2002/91.png)

Запусти веб-сервер **Apache** на ws22 только на localhost (то есть в файле */etc/apache2/ports.conf* измени строку `Listen 80` на `Listen localhost:80`).

![92.png](Linux%2002/92.png)

воспользуемся командой `ssh -L [local_port]:localhost:[local_port] [remote_ip]`

![95.png](Linux%2002/95.png)

проверим с помощью команды `telnet 127.0.0.1 5555`

![96.png](Linux%2002/96.png)

Воспользуйся *Remote TCP forwarding* c ws11 до ws22, чтобы получить доступ к веб-серверу на ws22 с ws11.

воспользуемся командой `ssh -R [remote_port]:localhost:[local_port] [remote_ip]`

![97.png](Linux%2002/97.png)

проверим с помощью команды `telnet 127.0.0.1 5555`

![98.png](Linux%2002/98.png)
