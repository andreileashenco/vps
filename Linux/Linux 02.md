# Linux 02

## Part 1. Инструмент **ipcal**

---

### 1.1. Сети и маски

---

1) Адрес сети *192.167.38.54/13*

![1.jpg](img/1.png)

2)Перевод маски *255.255.255.0* в префиксную и двоичную запись, */15* в обычную и двоичную, *11111111.11111111.11111111.11110000* в обычную и префиксную

![2.png](img/2.png)

![3.png](img/3.png)

3) Минимальный и максимальный хост в сети *12.167.38.4* при масках: */8*, *11111111.11111111.00000000.00000000*, *255.255.254.0* и */4*

### 1.2 localhost

---

можно ли обратиться к приложению, работающему на localhost, со следующими IP:

1. *194.34.23.100 - нет*
2. *127.0.0.2 - да (имеется loopback)*
3. *127.1.0.1 - да (имеется loopback)*
4. *128.0.0.1 - нет*

![4.png](img/4.png)
![5.png](img/5.png)
![6.png](img/6.png)
![7.png](img/7.png)

### 1.3 Диапазоны и сегменты сетей

---

![7-1.png](img/7-1.png)

1) Какие IP можно использовать в качестве публичного, а какие только в качестве частных

1. *10.0.0.45 - частные*
2. *134.43.0.2 - публичный*
3. *192.168.4.2 - частные*
4. *172.20.250.4 - частный*
5. *172.0.2.1 - публичный*
6. *192.172.0.1 - публичный*
7. *172.68.0.2 - публичный*
8. *172.16.255.255 - частный*
9. *10.10.10.10 - частные*
10. *192.169.168.1 - публичные*

2) Какие из IP адресов шлюза возможны у сети *10.10.0.0/18*:

1. *10.0.0.1 - невозможен*
2. *10.10.0.2 - возможен*
3. *10.10.10.10 - возможен*
4. *10.10.100.1 - невозможен*
5. *10.10.1.255 - возможен*

## Part 2. Статическая маршрутизация между двумя машинами

---

Подними две виртуальные машины (далее -- ws1 и ws2).

![8.jpg](img/8.jpg)

С помощью команды ip a посмотри существующие сетевые интерфейсы.
![0.jpg](img/0.png)
![00.jpg](img/00.png)
- Опиши сетевой интерфейс, соответствующий внутренней сети, на обеих машинах и задать следующие адреса и маски: ws1 - *192.168.100.10*, маска */16*, ws2 - *172.24.116.8*, маска */12*.

![11.png](img/11.png)
![12.png](img/12.png)

С помощью команды `ip a` посмотри существующие сетевые интерфейсы.

![9.png](img/9.png)

![10.png](img/10.png)

### 2.1. Добавление статического маршрута вручную

---

**Добавляем статический маршрут от одной машины до другой командой**

---

**Команда ip r add используется для добавления пользовательских маршрутов в таблицу маршрутизации, позволяет вручную настроить, каким образом пакеты будут направляться к определенным сетям или хостам, после перезагрузки системы настройки удаляются.**

**Для sw1 введем команду**
**sudo ip r add 172.24.116.8 via 192.168.100.10 dev enp0s8**
**добавив статический маршрут до ws2**
![013.png](img/013.png)

- - -

**Для sw2 введем команду**
**sudo ip r add 192.168.100.10 via 172.24.116.8 dev enp0s8**
**добавив статический маршрут до ws1**
![014.png](img/014.png)

---

**Пропингуем соединение с помощью ping -c 5 на обеих машинах**
![0141.png](img/0141.png)
![0142.png](img/0142.png)

---

**Перезапустим машины sudo reboot**
### 2.2. Добавление статического маршрута с сохранением
**Добавляем статический маршрут с сохранением от одной машины до другой с помощью файла *etc/netplan/00-installer-config.yaml***

![13.png](img/13.png)

![14.png](img/14.png)

**После внесения изменений вызвана команда sudo netplan apply и пропинговано соединение между машинами.**

**Пропингуем соединение между машинами**

![15.png](img/15.png)

![16.png](img/16.png)

## Part 3. Утилита **iperf3**

---

### 3.1. Скорость соединения

Переведи и запиши в отчёт: 8 Mbps в MB/s, 100 MB/s в Kbps, 1 Gbps в Mbps.

Чтобы перевести скорость из мегабитов в секунду (Mbps) в мегабайты в секунду (MB/s), нужно разделить значение в мегабитах на 8, так как в 1 байте содержится 8 битов.

- 8 Mbps == 1MB/s (/8)
- 100 MB/s == 800 000Kbps 
переводим мегабайты в мегабиты → 100MB/s * 8 == 800Mbps 
переводим мегабиты в килобиты → 800Mbps * 1 000 = 800 000Kbps
- 1 Gbps == 1 000Mbps (*1000)

### 3.2. Утилита **iperf3**

Измерь скорость соединения между sw1 и sw2.

**Устанавливаем утилиту iperf3**
sudo apt install iperf3

![17.png](img/17.png)


ws1 выступает в роли сервера iperf3 -s

![18.png](img/18.png)

ws2 выступает в роли клиента iperf3 -c 192.168.100.10
Далее происходил обмен трафиком, и выведена средняя скорость передачи данных - 2.19Gbps

![19.png](img/19.png)

## Part 4. Сетевой экран

---

### 4.1. Утилита **iptables**

(Ссылки на материалы по iptables [тут](https://www.opennet.ru/man.shtml?topic=iptables&category=8&russian=0) и [тут](https://losst.pro/nastrojka-iptables-dlya-chajnikov))

**Создаем файл /etc/firewall.sh, имитирующий фаерволл, на sw1 и sw2**

![21.png](img/21.png)

![22.png](img/22.png)

- на sw1 написать сначала запрещающее, а потом разрешающее правило на пинг
    
Запрещающее правило:
    
    `iptables -A OUTPUT -p icmp --icmp-type echo-reply -j DROP`
    
Разрешающее правило:
    
    `iptables -A OUTPUT -p icmp --icmp-type echo-reply -j ACCEPT`
- Проверка, что правила добавлены (sudo iptables -L --line-numbers)
![23.png](img/23.png)
- Запустим ping c sw2, увидим, что sw1 перестала пинговаться
![24-1.png](img/24-1.png)
- Запустим ping c sw1 на sw2, увидим что пингуется
![24-11.png](img/24-11.png)
- обратную последовательность команд добавим для sw2 (в начале пишется разрешающее правило, а в конце пишется запрещающее правило)
![23.png](img/23-1.png)
    
    Разрешающее правило:
    
    `iptables -A OUTPUT -p icmp --icmp-type echo-reply -j ACCEPT`
    
    Запрещающее правило:
    
    `iptables -A OUTPUT -p icmp --icmp-type echo-reply -j DROP`
![24.png](img/24.png)

- откроем на машинах доступ для порта 22 (ssh) и порта 80 (http)
`iptables -t filter -A INPUT -p tcp --dport 22 -j ACCEPT`
    
    `iptables -t filter -A INPUT -p tcp --dport 80 -j ACCEPT`
Файлы /etc/firewall.sh


Запусти файлы на обеих машинах командами `chmod +x /etc/firewall.sh` и `/etc/firewall.sh`.
- sw1

![25.png](img/25.png)

![26.png](img/26.png)

- sw2

![27.png](img/27.png)
![28.png](img/28.png)

### 4.2. Утилита **nmap**

Устанавливаем утилиту `sudo apt install nmap` .
Пингуем sw2 - sw1, видим, что отклика нет, после вызываем `nmap 192.168.100.10` и видим, что хост машины запущен.

sw-2

![29.png](img/29.png)
Host is up

- **Сохранение дампов образов виртуальных машин**
    
    Дамп - состояние машины.
    
    Сохраняем текущее состояние в интерфейсе VirtualBox.

![30.jpg](img/30.jpg)
![31.jpg](img/31.jpg)
сохранение дампов образов виртуальных машин
## Part 5. Статическая маршрутизация сети

---

### 5.1. Настройка адресов машин

Настрой конфигурации машин в *etc/netplan/00-installer-config.yaml* согласно сети на рисунке.
![map.png](img/map.png)
Поднял пять виртуальных машин: 3 рабочие станции (ws11, ws21, ws22) и 2 роутера (r1, r2)
![mashines.png](img/mashines.jpg)
Подключал несколько адаптеров  (два - для рабочих станций, и три - для роутеров) при поднятии машин. У всех машин в первом адаптере выбран NAT (ему соответствует интерфейс enp0s3).

ВАЖНО! От каждого включенного адаптера создается один сетевой интерфейс. Они создаются по порядку: enp0s3 (от адаптера 1),  enp0s8 (от адаптера 2) и enp0s9 (от адаптера 3).

На картинке с заданием мы видим два интерфейса: eth0 и eth1. Им в нашем случае будут соответствовать интерфейсы enp0s8 (от адаптера 2) и enp0s9 (от адаптера 3).
![map1.png](img/map1.jpg)
!!!!! При поднятии машин обратить внимание, что у роутера r2 на картинке с заданием  интерфейс eth1 (то есть enp0s9) метчится с машинами ws21 и ws22 через интерфейс eth0 (то есть enp0s8) .
Поэтому, так как интерфейс enp0s9 соответствует адаптеру 3, а интерфейс enp0s8 соответствует адаптеру 2, то делаем вывод, что общая сеть для машин ws21, ws22 и r2 должна подключаться у r2 через адаптер 3, а у машин через адаптер 2.


5.1. Настройка адресов машин
- В отчёт помести скрины с содержанием файла *etc/netplan/00-installer-config.yaml* для каждой машины.

ws11

![32.png](img/32.png)

sws21

![33.png](img/33.png)

ws22

![34.png](img/34.png)

r1

![35.png](img/35.png)

r2

![36.png](img/36.png)

Сохраняем результат с помощью `sudo netplan apply`

Командой `ip a` проверяем, что адреса машин заданы верно

ws11

![37.png](img/37.png)

ws21

![38.png](img/38.png)

ws22

![39.png](img/39.png)

r1

![40.png](img/40.png)

r2

![41.png](img/41.png)

Пропингуем ws22 с ws21

![42.png](img/42.png)

Пропингуем r1 с ws11.

![43.png](img/43.png)

### 5.2. Включение переадресации IP-адресов

Для включения переадресации IP, выполни команду на роутерах:

`sudo sysctl -w net.ipv4.ip_forward=1`

r1

![44.png](img/44.png)

r2

![45.png](img/45.png)

В файл  */etc/sysctl.conf* и добавили в него строку
При выполнении вышеуказанной команды переадресация не будет работать после перезагрузки системы, поэтому в файле /etc/sysctl.conf  расскомментируем следующую строку - net.ipv4.ip_forward = 1

r1

![46.png](img/46.png)

r2

![47.png](img/47.png)

`net.ipv4.ip_forward = 1`*При использовании этого подхода, IP-переадресация включена на постоянной основе.*

### **5.3. Установка маршрута по-умолчанию**

Настроим маршрут по умолчанию (шлюз) для рабочих станций, для этого добавим default перед IP роутера в файле конфигураций

Пример вывода команды `ip r` после добавления шлюза:

```
default via 10.10.0.1 dev eth0
10.10.0.0/18 dev eth0 proto kernel scope link src 10.10.0.2

```

Настроили маршрут по-умолчанию (шлюз) для рабочих станций. Для этого добавили `default` перед IP роутера в файле конфигураций.

ws11

![48.png](img/48.png)

ws21

![49.png](img/49.png)

ws22

![50.png](img/50.png)


Проверка, что маршрут добавился в таблицу маршрутизации  ip r

ws11

![51.png](img/51.png)

ws21

![52.png](img/52.png)

ws22

![53.png](img/53.png)

Для того, чтобы пропинговать с ws11 роутер r2,  используем команду используем команду 
`tcpdump -tn -i enp0s9`


Запускаем tcpdump на r2, чтобы отслеживать трафик на машине
`tcpdump -tn -i enp0s9`
![54.png](img/54.png)

C ws11 начинаем пинговать r2  ping -c 5 10.100.0.12
![55.png](img/55.png)

На r2 видим, что запросы получены 
![56.png](img/56.png)
Роутер r2 получает запросы echo request , но ответ не отправляет, так как не прописан обратный адрес.
### 5.4. Добавление статических маршрутов
![56.png](img/map29.png)
Добавили в роутеры r1 и r2 статические маршруты в файле конфигураций


для r1 шлюзом в сеть 10.20.0.0 будет 10.100.0.12
![57.png](img/57.png)
![map30.png](img/map30.png)
для r2 шлюзом в сеть 10.10.0.0 будет 10.100.0.11
![58.png](img/58.png)

С помощью ip r убедимся, что статический маршрут добавлен r1
![59.png](img/59.png)
С помощью ip r убедимся, что статический маршрут добавлен r2
![60.png](img/60.png)

**Запустить команды на ws11:**

Вызов команды `ip r list 10.10.0.0/18` выведет информацию о маршруте, связанном с конкретной подсетью.

Вызов команды `ip r list 0.0.0.0/0` используется для вывода информации о маршруте по умолчанию. Подсеть `0.0.0.0/0` представляет собой маршрут по умолчанию, который охватывает все возможные IP-адреса. Он указывает, как отправлять сетевой трафик, который не имеет явно заданного маршрута, или для которого не существует более конкретных маршрутов.
![61.png](img/61.png)
Для адреса 10.10.0.0/18 был выбран маршрут, отличный от 0.0.0.0/0, так как машина ws11 соединена с сетью 10.10.0.0/18 по своему IP-адресу 10.10.0.2, для других адресов используется маршрут по умолчанию, который указан в файле - 10.10.0.1.

Если указать адрес, то будет выбран прямой маршрут, в противном случает будет маршрут по умолчанию, т.е. до ближайшего узла.

### **5.5. Построение списка маршрутизаторов**
Запускаем на r1 команду дампа `tcpdump -tnv -i enp0s8`

Опции -tnv указывают `tcpdump` отобразить вывод в числовом формате, без разбора имен хостов и портов, и включить подробную информацию о пакетах.
![62.png](img/62.png)
запущена команда отслеживания сетевого трафика в реальном времени на r1

На ws11 запустили traceroute 10.20.0.10
Установка traceroute
sudo apt install traceroute
![63.png](img/63.png)
список маршрутизаторов на пути от ws11 до ws2


Принцип работы утилиты `traceroute` основан на отправке сетевых **пакетов с TTL** и анализе ответов от промежуточных узлов сети. 
**Пакет данных с TTL**  означает сетевой пакет, в котором задано значение TTL, которое определяет количество промежуточных узлов, через которые пакет может проходить, прежде чем быть отброшенным. TTL является частью заголовка IP-пакета и используется для предотвращения зацикливания или бесконечного циркулирования пакетов в сети.
Вот как происходит построение пути при помощи `traceroute`:

1. Когда запускается `traceroute` к какому-либо адресу (IP-адресу или доменному имени), он начинает отправлять пакеты данных с TTL (Time To Live), установленным на 1, к указанному адресу. 
2. Первый узел (роутер) в сети, через который проходит пакет, уменьшает значение TTL на 1. Если после уменьшения значение TTL становится равным 0, узел отбрасывает пакет и отправляет обратно сообщение "Time Exceeded" обратно отправителю.
3. Отправитель `traceroute` записывает информацию о первом узле, через который прошел пакет, а затем увеличивает значение TTL на 1 и отправляет следующий пакет.
4. Процесс повторяется: каждый промежуточный узел уменьшает TTL, и если TTL достигает 0, он отправляет обратно сообщение "Time Exceeded". Отправитель записывает информацию об этом узле и переходит к следующему шагу.
5. Когда пакет наконец достигает финального пункта назначения (конечного IP-адреса), пункт назначения отправляет ответ "ICMP Echo Reply" (если протокол ICMP используется для пакетов), который достигает отправителя `traceroute`.
6. `traceroute` завершает свою работу, предоставляя список всех узлов (роутеров), через которые проходили пакеты, и информацию о времени, которое требовалось для прохождения каждого узла.

Таким образом, `traceroute` позволяет отследить маршрут, который пакеты данных проходят от отправителя к получателю через сеть, а также измерить задержки (пинг) на каждом промежуточном узле.
### **5.6. Использование протокола ICMP при маршрутизации**
Запускаем на r1 перехват сетевого трафика tcpdump -n -i enp0s8
![64.png](img/64.png)
запущена команда отслеживания сетевого трафика в реальном времени на r1

Пингуем с ws11 несуществующий IP с помощью командыping -c 1 10.30.0.111
![65.png](img/65.png)
ping несуществующего адреса с ws11

Видим, что tcpdump отловил запрос 
![66.png](img/66.png)
tcpdump отловил запрос на r1

Сохраняем дампы образов виртуальных машин
![dump.png](img/dump.jpg)
дампы образов виртуальных машин после выполнения задания №5
### Part 6. Динамическая настройка IP с помощью DHCP 
- **Настроим на машине r2 службу DCHP**
    
    Для r2 настраиваем в файле /etc/dhcp/dhcpd.conf конфигурацию службы DHCP.
    
    Чтобы появился файл, который будем редактировать нужно установить пакет 
    `apt-get install isc-dhcp-server` .
    Утилита`isc-dhcp-server` позволяет настроить и управлять сервером DHCP, предоставляя IP-адреса и другие параметры клиентам.
![67.png](img/67.png)

В файле /etc/resolv.conf пропишем nameserver 8.8.8.8
![68.png](img/68.png)
     Файл resolv.conf содержит информацию о настройках DNS (Domain Name System) в операционной системе Linux. Он указывает системе, какие DNS-серверы использовать для разрешения доменных имен в IP-адреса.
     
     - Перезагружаем службу DHCP командой systemctl restart isc-dhcp-server  

![69.png](img/69.png)